
REPOSITORY 

Represents the complete state and history of a number of files to keep
synchronized.

- A repository is identified by a UUID
- A repository has a HISTORY, which in turn consists of multiple COMMITS
- Syncing synchronizes these histories between different instances of the
  repository

REPOSITORY INSTANCE

- Is a physical checkout of a repository
- Has a UUID and a (short) name
- Has locations of other instances to sync with ("remotes")


HISTORY


COMMIT

- Contains file metadata and file content id (hash)
- Is either initial commit or has one or more parent commits

- [???] Contains locations of files
- [???] Contains should-have locations of files
        That is, a file can be in either of the following states:

		a) The file is not present in this instance and shoud not be
		b) The file is present in this instance in the exact version it should
		   be
		c) The file is not present in this instance but should be there in
		   version X
		d) The file is present in version X but should be there in version Y

-----> There are different states to synchronize in an instance:

       - History from other instances, merged with the local history (commits)
       - Should-be states of files: Should they go into a commit or should
		 there be a dedicated transfer-todo list?

		 Idea:
		 - Only ever commit after the instance is at the state the commit
		   expresses.
		 - That is, getting a file works as follows:
		   1. Put the file download on the transfer todo list
		   2. Execute transfer (by user command)
		   3. commit the new state (automatically)




